---
import { z } from 'zod'
import { attributesSchema } from '../schemas/attributesSchema'

type Props = z.infer<typeof tagSchema> & Record<any, any>

export const tagSchema = z.object({})
// export const tagSchema = z
//   .object({
//     as: elementsSchema.optional(),
//     if: z.union([z.string(), z.literal(true)]),
//     html: z.string(),
//     color: z.string(),
//     scheme: z.string(),
//     contrast: z.boolean(),
//     class: z.string(),
//     id: z.string(),
//     style: z.string(),
//     scale: z.string().or(z.number()), // TODO remove scale and fix sizing system. people can just use css scale
//     size: z
//       .enum(['1', '2', '3', '4'])
//       .or(z.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4)])),
//     compact: z.boolean(),
//     order: z.string().or(z.number()),
//   })
//   .partial()

// const {
//   as: As = 'div',
//   if: hasProp,
//   html,
//   color,
//   scheme,
//   contrast,
//   order,
//   scale,
//   size,
//   compact,
//   ...rest
// } = Astro.props

// const slot = await Astro.slots.render('default')
// const hasSlot = slot?.trim().length > 0
---

<!-- {
  (hasSlot || hasProp || html) && (
    <As
      style={
        `
        ${scale ? `--scale:${scale};` : ''}
        ${order ? `order:${order};` : ''}
      `.trim() || undefined
      }
      class:list={[
        { compact, contrast },
        color ? `hue-${color}` : '',
        size ? `size-${size}` : '',
        scheme,
      ]}
      {...attributesSchema.parse(rest)}
    >
      <Fragment set:html={html} />
      <Fragment set:html={slot} />
    </As>
  )
} -->
