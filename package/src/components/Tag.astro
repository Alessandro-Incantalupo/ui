---
import { z } from 'astro:content'
import { zElements } from '../utils'

type Props = z.infer<typeof schema>

// const prefixAttributes = z.record(
//   z
//     .string()
//     .refine((key) =>
//       ['on', 'data-', 'aria-'].some((prefix) => key.startsWith(prefix))
//     ),
//   z.string().nullish()
// ) as z.ZodType<{
//   [Key in `${'on' | 'data-' | 'aria-'}${string}`]: string | null | undefined
// }>

export const schema = z.object({
  // element
  as: zElements.optional(),
  if: z.union([z.string(), z.literal(true)]).nullish(),
  // theme
  color: z.string().nullish(),
  scheme: z.string().nullish(),
  contrast: z.boolean().nullish(),
  scale: z.string().or(z.number()).nullish(), // TODO remove scale and fix sizing system. people can just use css scale
  size: z
    .enum(['1', '2', '3', '4'])
    .or(z.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4)]))
    .nullish(),
  compact: z.boolean().nullish(),
  order: z.string().or(z.number()).nullish(),
  // global
  class: z.string().nullish(),
  id: z.string().nullish(),
  onclick: z.string().nullish(),
  // specific
  src: z.string().nullish(),
  alt: z.string().nullish(),
  sizes: z.string().nullish(),
  href: z.string().nullish(),
  type: z.string().nullish(),
  method: z.string().nullish(),

  // loading: z.string().nullish(),
})

const {
  as: As = 'div',
  if: If,
  color,
  scheme,
  contrast,
  order,
  scale,
  size,
  compact,
  ...rest
} = schema.parse(Astro.props)

const slot = await Astro.slots.render('default')
const hasContent = slot?.trim().length > 0
const hasProp = If === true || (If && If in rest)
---

{
  (hasProp || hasContent) && (
    <As
      style={`
        ${scale ? `--scale:${scale};` : ''}
        ${order ? `order:${order};` : ''}
      `.trim()}
      class:list={[
        { compact, contrast },
        color ? `hue-${color}` : '',
        size ? `size-${size}` : '',
        scheme,
      ]}
      {...rest}
    >
      <Fragment set:html={slot} />
    </As>
  )
}
