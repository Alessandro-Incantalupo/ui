---
import { z } from 'zod'
import { attributesSchema } from '../schemas/attributesSchema'
import { elementsSchema } from '../schemas/elementsSchema'
import { zodObjectwithReadableError } from '../utils/zodObjectwithReadableError'

type Props = z.infer<typeof tagSchema> & Record<any, any>

export const componentSchema = <S extends z.ZodRawShape>(shape: S = {} as S) =>
  zodObjectwithReadableError({
    as: elementsSchema,
    if: z.union([z.string(), z.literal(true)]),
    html: z.string(),
    id: z.string(),
    class: z.string(),
    style: z.string(),
    color: z.string(),
    scheme: z.string(),
    contrast: z.boolean(),
    compact: z.boolean(),
    order: z.string().or(z.number()),
    size: z
      .enum(['1', '2', '3', '4'])
      .or(z.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4)])),
    ...shape,
  }).partial()

export const tagSchema = componentSchema()

const {
  as: As = 'div',
  if: hasProp,
  html,
  order,
  compact,
  contrast,
  color,
  size,
  scheme,
  ...rest
} = Astro.props

const slot = await Astro.slots.render('default')
const hasSlot = slot?.trim().length > 0
---

{
  (hasSlot || hasProp || html) && (
    <As
      style={order ? `order:${order};` : undefined}
      class:list={[
        { compact, contrast },
        color ? `hue-${color}` : '',
        size ? `size-${size}` : '',
        scheme ? `scheme-${scheme}` : '',
        scheme,
      ]}
      {...attributesSchema.parse(rest)}
    >
      <Fragment set:html={html} />
      <Fragment set:html={slot} />
    </As>
  )
}
